# Шпаргалка по консольным командам Git



## Общее

Git — система контроля версий (файлов). Что-то вроде возможности сохраняться в компьютерных играх (в Git эквивалент игрового сохранения — коммит).

Любой файл в папке существующего репозитория может находиться или не находиться под версионным контролем (отслеживаемые и неотслеживаемые).

Неотслеживаемые файлы можно в любой момент сделать отслеживаемыми и наоборот.

Отслеживаемые файлы могут быть в 3-х состояниях: неизменённые, изменённые, готовые к коммиту. Сразу после клонирования репозитория все файлы — отслеживаемые неизменённые.

После редактирования отслеживаемого файла он становится изменённым. Изменения файла (или нескольких) можно индексировать (подготовить к коммиту) и закоммитить. После коммита такие файлы становятся отслеживаемыми неизменёнными.

Проверить состояние репозитория можно командой `git status`. Она покажет ветку, изменённые файлы (если есть) с пометкой «modified», неотслеживаемые файлы в списке «Untracked files». 


Файл .gitignore
Иногда из репозитория Git следует исключить некоторые файлы. Это можно сделать, создав специальный файл под названием .gitignore. Полезные шаблоны для .gitignore файлов можно найти на github.com/github/gitignore .
в файл .gitignore записываются имена файлов и папок, которые не нужно отслеживать Git.

git ls-files --other --ignored --exclude-standard — список всех игнорируемых файлов.







## Консольные команды




### Настройка конфигурации. 
Задать имя пользователя и адрес электронной почты


Имя пользователя нужно, чтобы привязывать коммиты к вашему имени. Это не то же самое, что имя пользователя учётной записи GitHub, с помощью которого выполняется вход в профиль на GitHub. Задать или изменить имя пользователя можно с помощью команды git config. Новое имя будет автоматически отображаться в последующих коммитах, отправленных на GitHub через командную строку. Если хотите скрыть своё реальное имя, можно использовать в качестве имени пользователя Git произвольный набор символов.
Кроме того, командой git config можно изменять адрес электронной почты, привязанный к вашим коммитам Git. Новый адрес электронной почты будет автоматически отображаться во всех дальнейших коммитах, поданных на GitHub через командную строку.

git config --global user.name "[name]" — установить имя, которое будет прикрепляться к коммиту.
git config --global user.email "[email address]" — установить email, который будет прикрепляться к коммиту.
git config --global color.ui auto — включить полезную подсветку командной строки.
git config --global push.default current — обновлять удаленную ветку с таким же именем, что и локальная, при пуше изменений (если не указано иного).
git config --global core.editor [editor] — установить редактор для редактирования сообщений коммита.
git config --global diff.tool [tool] — установить программу для разрешения конфликтов при слиянии.

git config --list --global	        # просмотреть настройки GIT












### Создать новый репозиторий


git init                 # создать новый проект в текущей папке
git init folder-name    # создать новый проект в указанной папке







### Клонирование репозитория


git clone [url]                 # клонировать удаленный репозиторий в одноименную папку
git clone [url]  foldername    # клонировать удаленный репозиторий в папку «foldername»








### Добавление файлов к отслеживанию, индексация отслеживаемых


git add text.txt                # добавить к отслеживанию этот существующий файл
git add .                       # добавить к отслеживанию все новые файлы из текущей папки и её подпапок, индексировать отслеживаемые файлы
git add -i                       # запуск оболочки интерактивного индексирования для добавления в индекс только выбранных файлов 
git add '*.txt' — добавить только файлы, соответствующие указанному выражению.
git add --patch filename — позволяет выбрать какие изменения из файла добавятся в коммит.

(см. [git-scm.com](http://git-scm.com/book/ru/v1/%D0%98%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D1%8B-Git-%D0%98%D0%BD%D1%82%D0%B5%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B5-%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5))








### Проверка статуса репозитория


Просмотреть статус нужного репозитория можно по ключевому слову status: его действие распространяется на подготовленные, неподготовленные и неотслеживаемые файлы.

git status — полный список изменений файлов, ожидающих коммита.
git status -s — краткий вид изменений.










### Просмотр изменений


git diff            # посмотреть непроиндексированные изменения (если есть, иначе ничего не выведет)
git diff FileName	# просмотр всех изменений в конкретном файле
git diff --staged   # посмотреть проиндексированные изменения (если есть, иначе ничего не выведет)
git diff HEAD       # показать что изменилось с последнего коммита.
git diff HEAD^      # показать что изменилось с предпоследнего коммита.
git diff [branch]   # сравнить текущую ветку с заданной.
git diff --stat     # показать статистику какие файлы были изменены и как.

git difftool -d — то же самое, что и diff, но показывает изменения в заданной difftool.
git difftool -d master.. — показать изменения, сделанные в текущей ветке.

blame		            # отображение метаданных автора, связанных со строками, которые были внесены в файл при коммите.
git blame FileName		# посмотреть когда и кем редактировалась каждая строка файла в последний раз











### Отмена изменений


Восстановить файлы рабочего дерева, не подготовленные к коммиту, можно параметром checkout. Для проведения операции требуется указать путь к файлу. Если путь не указан, параметр git checkout изменит указатель HEAD, чтобы задать указанную ветку как текущую.

git checkout somefile.js
git checkout .					# откат изменений во всех файлах

Восстановить подготовленный файл рабочего дерева можно параметром reset. Потребуется указать путь к файлу, чтобы убрать его из области подготовленных файлов. При этом не будет производиться откат никаких изменений или модификаций — однако файл перейдёт в категорию не подготовленных к коммиту.

git reset HEAD somefile.js
git reset HEAD          # Если нужно выполнить это действие для всех подготовленных файлов, путь к ним указывать не надо.














### Отмена индексации

git reset HEAD              # убрать из индекса все индексированные файлы
git reset HEAD text.txt     # убрать из индекса указанный файл
git reset [file]            # убрать файлы из индекса коммита (изменения не теряются).













### Коммиты

При создании коммита в репозитории можно добавить однострочное сообщение с помощью параметра commit с флагом -m. Само сообщение вводится непосредственно после флага, в кавычках.

git commit -m "Your short summary about the commit"

Также можно открыть текстовый редактор в терминале для написания полного сообщения коммита. Оно может состоять из нескольких строк текста, в котором подробно характеризуются изменения, внесённые в репозиторий.

git commit                          # закоммитить отслеживаемые индексированные файлы (откроется редактор для введения названия коммита)
git commit -a				        # добавление в коммит всех непроиндексированых файлов(git add . +  git commit )
git commit -m "Name of commit"      # закоммитить отслеживаемые индексированные файлы (указано название коммита)
git commit -m -a "Name of commit"   # закоммитить отслеживаемые индексированные файлы (указано название коммита, не требует git add, не добавит в коммит неотслеживаемые файлы)
git commit --amend                  # изменить последний коммит (Insert — режим ввода, : — командный режим; в командном режиме: :wq — сохранить и выйти)










### Изменение последнего коммита

Внести изменения в последний коммит можно параметром commit с флагом --amend. Например, вы записали изменения, внесённые в ряд файлов, и поняли, что допустили ошибку в сообщении коммита. В этом случае можете воспользоваться указанной командой, чтобы отредактировать сообщение предыдущего коммита, не изменяя его снимок.

git commit --amend -m "Updated message for the previous commit"

Также можно вносить изменения в файлы, отправленные ранее. Например, вы изменили несколько файлов в ряде папок и хотите их записать как единый снимок, но забыли добавить в коммит одну из папок. Чтобы исправить такую ошибку, достаточно подготовить для фиксации остальные файлы и папки и создать коммит с флагами --amend и --no-edit.

git add dir1
git commit

# Here you forgot to add dir2 to commit, you can execute the
following command to amend the other files and folders.

git add dir2
git commit --amend --no-edit

Флаг --no-edit позволит внести в коммит поправку без изменения сообщения коммита. В этом случае итоговый коммит заменит неполный, а выглядеть это будет так, как будто мы отправили изменения ко всем файлам в нужных папках как единый снимок.

Внимание! Не изменяйте публичные коммиты.

С помощью amend прекрасно исправляются локальные коммиты, а исправления можно передать в общий репозиторий. Однако изменять коммиты, уже доступные другим пользователям, не следует. Помните, что изменённые коммиты являются совершенно новыми, а предыдущий коммит уже не будет доступен в текущей ветке. Последствия будут такими же, как при отмене изменений публичного снимка.










### Отмена коммитов


git revert HEAD --no-edit           # создать новый коммит, отменяющий изменения последнего коммита (без запуска редактора сообщения)
git reset --hard 75e2d51            # вернуть репозиторий в состояние коммита с указанным хешем

Откат последнего коммита
Откатить последний коммит можно с помощью параметра revert. Создастся новый коммит, содержащий обратные преобразования относительно предыдущего, и добавится к истории текущей ветки.

git revert HEAD                     # Откат последнего коммита
git revert 1af17e                   # Откат заданного коммита

*** Разница между revert и reset
Команда git revert отменяет изменения, записанные только одним коммитом. Она не откатывает проект к более раннему состоянию, удаляя все последующие коммиты, как это делает команда git reset.
У команды revert есть два крупных преимущества по сравнению с reset. Во-первых, она не меняет историю проекта и производит операцию, безопасную для коммитов. Во-вторых, её объектом выступает конкретный коммит, созданный в любой момент истории, а git reset всегда берёт за точку отсчёта текущий коммит. К примеру, если нужно отменить старый коммит с помощью git reset, придётся удалить все коммиты, поданные после целевого, а затем выполнить их повторно. Следовательно, команда git revert — гораздо более удобный и безопасный способ отмены изменений.











### Удаление файла (просто удалить отслеживаемый файл из папки недостаточно, нужно сделать его неотслеживаемым и отправить коммит)


git rm [file]               # удалить файл из рабочей директории и добавить в индекс информацию об удалении.
git rm --cached [file]      # удалить файл из репозитория, но сохранить его локально.
git rm -f text.txt          # удалить из отслеживаемых индексированный файл (файл будет удален из папки)
git rm -r log/              # удалить из отслеживаемых всё содержимое папки log/ (папка будет удалена)
git rm ind*                 # удалить из отслеживаемых все файлы с именем, начинающимся на «ind» в текущей папке (файлы будут удалены из папки)












### Перемещение/переименование файлов (Git не отслеживает перемещения/переименование, но пытается его угадать)


Переименовать файл или папку можно параметром mv. Для него указывается источник source и назначение destination. Источник — реально существующий файл или папка, а назначение — существующая папка.
При выполнении команды файл или папка, указанные как источник, будут перемещены в папку назначения. Индекс будет обновлён соответственно, но изменения нужно записать.

git mv text.txt test_new.txt    # переименовать файл «text.txt» в «test_new.txt»
git mv readme_new.md folder/    # переместить файл readme_new.md в папку folder/ (должна существовать)












### Сохранение фрагментов


stash					временное хранилище изменений в файле
git stash				сохраняет неподтвержденные изменения (индексированные и неиндексированные) в 
						отдельном хранилище, чтобы вы могли вернуться к ним позже
git stash list          # список всех сохраненных изменений во временном хранилище.
git stash drop          # удалить последние файлы, положенные во временное хранилище.
git stash pop		    # применить ранее отложенные изменения
git stash clear		    # удаляет все наборы отложенных изменений
git stash -u		    # позволяет отложить неотслеживаемые файлы
git stash show		    # просмотреть сводные данные по набору отложенных изменений










### История изменений (просмотр коммитов)


Просматривать изменения, внесённые в репозиторий, можно с помощью параметра log. Он отображает список последних коммитов в порядке выполнения. Кроме того, добавив флаг -p, вы можете подробно изучить изменения, внесённые в каждый файл.

опции
-(n)Показывает только последние n коммитов.
--since, --after	Показывает только те коммиты, которые были сделаны после указанной даты.
--until, --before	Показывает только те коммиты, которые были сделаны до указанной даты.
--author	        Показывает только те коммиты, в которых запись author совпадает с указанной строкой.
--committer	        Показывает только те коммиты, в которых запись committer совпадает с указанной строкой.
--grep	            Показывает только коммиты, сообщение которых содержит указанную строку.
-S	                Показывает только коммиты, в которых изменение в коде повлекло за собой добавление или удаление указанной строки.

git log             # список изменения текущей ветки.
git log -2          # показать последние 2 коммита
git log -2 --stat   # показать последние 2 коммита и статистику внесенных ими изменений
git log -p -22      # показать последние 22 коммита и внесенную ими разницу на уровне строк (выход из длинного лога: Q)
git log --pretty=format:"%h - %an, %ar : %s" -4     # показать последние 4 коммита с форматированием выводимых данных
git log --pretty=format:"%h %s" --graph             # изменение вида отображения истории изменений.
git log --graph -10     # показать последние 10 коммитов с ASCII-представлением ветвления
git log --since=2.weeks # показать коммиты за последние 2 недели
git log --pretty=format:"%h %ad | %s%d [%an]" --graph --date=short  # мой формат вывода, висящий на алиасе оболочки
git log master..branch_99   # показать коммиты из ветки branch_99, которые не влиты в master
git log branch_99..master   # показать коммиты из ветки master, которые не влиты в branch_99
git log --follow [file]     # список изменения текущего файла, включая переименования.
git log --author='Name' --after={1.week.ago} --pretty=oneline --abbrev-commit   # посмотреть над чем работал заданный пользователь последнюю неделю.
git log --author AuthorName		# посмотреть все коммиты которые делал етот автор
git log --no-merges master..    # посмотреть историю изменений только для текущей ветки.

git show 60d6582                # показать изменения из коммита с указанным хешем
git show HEAD^                  # показать данные о предыдущем коммите
git show [branch]:[file]        # посмотреть на файл в другой ветке, не переключаясь на неё.

git diff [file-branch]..[second-branch] # посмотреть различия между двумя заданными ветками.

Просмотреть историю коммитов в виде графика для текущей ветки можно с помощью параметра log и флагов --graph --oneline --decorate. Опция --graph выведет график в формате ASCII, отражающий структуру ветвления истории коммитов. В связке с флагами --oneline и --decorate, этот флаг упрощает понимание того, к какой ветке относится каждый коммит.

git log --graph --oneline --decorate

Для просмотра истории коммитов по всем веткам используется флаг --all.

git log --all --graph --oneline --decorate












### Просмотр заданного коммита

Просмотреть полный список изменений, внесённых конкретным коммитом, можно с помощью параметра show, указав идентификатор или хеш коммита. Значение хеша уникально для каждого коммита, созданного в вашем репозитории.Также можно использовать сокращённый хеш.

git show 1af17e73721dbe0c40011b82ed4bb1a7dbe3ce29
git show 1af17e











### Просмотр изменений до коммита


Можно просматривать список изменений, внесённых в репозиторий, используя параметр diff. По умолчанию отображаются только изменения, не подготовленные для фиксации.
Для просмотра подготовленных изменений необходимо добавить флаг --staged.
Также можно указать имя файла как параметр и просмотреть изменения, внесённые только в этот файл.

git diff
git diff --staged
git diff somefile.js










### Ветки


git branch              # показать список веток
git branch -v           # показать список веток и последний коммит в каждой
git branch new_branch   # создать новую ветку с указанным именем

git merge [branch]      # соединить изменения в текущей ветке с изменениями из заданной.
git merge --no-ff [branch]  # соединить ветки без режима “fast forwarding”.

git branch -d hotfix        # удалить ветку hotfix (если её изменения уже влиты в главную ветку)
git branch -D [branch]      # принудительно удалить заданную ветку, игнорируя ошибки.
git branch --merged         # показать ветки, уже слитые с активной (их можно удалять)
git branch --no-merged      # показать ветки, не слитые с активной
git branch -a               # посмотреть полный список локальных и удаленных веток.
git branch -m <oldname> <newname>   # переименовать ветку.

git checkout -b new_branch          # создать новую ветку с указанным именем и перейти в неё
git checkout -b <name> <remote>/<branch>        # переключиться на удаленную ветку.
git checkout [branch-name]      # переключиться на указанную ветку и обновить рабочую директорию.
git checkout [filename]         # вернуть файл в первоначальное состояние если он еще не был добавлен в индекс коммита.
git checkout .					# откат изменений во всех файлах









### Oтправка изменений. Отправка новой ветки в удалённый репозиторий


git push						загрузка изменений на удаленный сервер

Передать новую ветку в удалённый репозиторий можно параметром push с флагом -u, указав имя репозитория и имя ветки.
git push -u origin BranchName 		# (создать новую ветку)устанавливаете связь между 
	той веткой, в которой вы находитесь и веткой master(main) на удалённом сервере. Команду требуется выполнить единожды,
	чтобы потом можно было отправлять/принимать изменения лишь выполняя git push из ветки без указания всяких
	алиасов для сервера и удалённых веток
git push <remote> <branch>		    # отправка ветки на удаленный сервер;
git push [bookmark] :[branch]       # в удаленном репозитории удалить заданную ветку.
git push origin :<branchName> 	    # удаление ветки на локальном сервере;
git push <remote> <tag>			    # обмен метками;

git push origin --delete NameBranch	    # удалить ветку на удалённом сервере
git push origin --all				    # запушить все ветки








### Удаление ветки

Удалить ветку можно параметром branch с добавлением флага -d и указанием имени ветки. Если вы завершили работу над веткой и объединили её с основной, можно её удалить без потери истории. Однако, если выполнить команду удаления до слияния — в результате появится сообщение об ошибке. Этот защитный механизм предотвращает потерю доступа к файлам.

git branch -d existing_branch_name
git branch -d hotfix                # удалить ветку hotfix (если её изменения уже влиты в главную ветку)

Для принудительного удаления ветки используется флаг -D с заглавной буквой. В этом случае ветка будет удалена независимо от текущего статуса, без предупреждений.

git branch -D existing_branch_name

Вышеуказанные команды удаляют только локальную копию ветки. В удалённом репозитории она может сохраниться. Если хотите стереть удалённую ветку, выполните следующую команду:

git push origin --delete existing_branch_name
git push --delete origin existing_branch

git push [bookmark] :[branch]       # в удаленном репозитории удалить заданную ветку.









### Слияние двух веток

Объединить две ветки можно параметром merge с указанием имени ветки. Команда объединит указанную ветку с основной.

git merge existing_branch_name

Если надо выполнить коммит слияния, выполните команду git merge с флагом --no-ff.

git merge --no-ff existing_branch_name

Указанная команда объединит заданную ветку с основной и произведёт коммит слияния. Это необходимо для фиксации всех слияний в вашем репозитории.

git merge	слияние веток(скачаных с удаленного репозитория и веток на локальном компьютере  )
git merge --abort	скачиваем конфликтные изменения на локальную машину








### Прекращение слияния при конфликте

Прервать слияние в случае конфликта можно параметром merge с флагом --abort. Он позволяет остановить процесс слияния и вернуть состояние, с которого этот процесс был начат.

git merge --abort

Также при конфликте слияния можно использовать параметр reset, чтобы восстановить конфликтующие файлы до стабильного состояния.

git reset









### Использование перебазирования

Для доступа к этой функции используйте параметр rebase с указанием имени ветки. Перебазирование — это процесс объединения или перемещения последовательности коммитов на новый родительский снимок.

git rebase branch_name

Эта команда изменит основу ветки с одного коммита на другой, как если бы вы начали ветку с другого коммита. В Git это достигается за счёт создания новых коммитов и применения их к указанному базовому коммиту. Необходимо понимать, что, хотя ветка и выглядит такой же, она состоит из совершенно новых коммитов.









### Удалённые репозитории


git remote -v                   # показать список удалённых репозиториев, связанных с этим
git remote add origin [URL]     # добавить удалённый репозиторий (с сокр. именем origin) с указанным URL
git remote show origin          # получить данные об удалённом репозитории с сокращенным именем origin
git fetch origin                # скачать все ветки с удаленного репозитория (с сокр. именем origin), но не сливать со своими ветками
git fetch origin master         # то же, но скачивается только указанная ветка
git checkout origin/github_branch     # посмотреть ветку, скачанную с удалённого репозитория (локальной редактируемой копии не создаётся! если нужно редактировать, придётся влить)
git checkout --track origin/github_branch   # создать локальную ветку github_branch (данные взять из удалённого репозитория с сокр. именем origin, ветка github_branch) и переключиться на неё
git push origin master          # отправить в удалённый репозиторий (с сокр. именем origin) данные своей ветки master
git pull origin                 # влить изменения с удалённого репозитория (все ветки)
git pull origin master          # влить изменения с удалённого репозитория (только указанная ветка)

Добавить удалённый репозиторий можно параметром remote add, указав shortname и url требуемого репозитория.

git remote add awesomeapp https://github.com/someurl..

Просматривать удалённые URL-адреса можно параметром remote с флагом -v. Этот параметр отображает удалённые подключения к другим репозиториям.Такая команда открывает доступ к интерфейсу управления удалёнными записями, которые хранятся в файле .git/config репозитория.

git remote -v

Получить подробные сведения об удалённом репозитории можно с помощью параметра remote show с указанием имени репозитория — например, origin.Эта команда отображает список веток, связанных с удалённым репозиторием, а также рабочих станций, подключённых для получения и отправки файлов.

git remote show origin

Отправлять изменения в удалённый репозиторий можно параметром push с указанием имени репозитория и ветки.
Эта команда передаёт локальные изменения в центральный репозиторий, где с ними могут ознакомиться другие участники проекта.

git push origin main

Для загрузки изменений из удалённого репозитория используется параметр pull. Он скачивает копию текущей ветки с указанного удалённого репозитория и объединяет её с локальной копией.
Также можно просмотреть подробные сведения о загруженных файлах с помощью флага --verbose.

git pull
git pull --verbose

Слияние удалённого репозитория с локальным
Слияние удалённого репозитория с локальным выполняется параметром merge с указанием имени удалённого репозитория.

git merge origin




